<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Java | Personal Interview Notes]]></title>
  <link href="http://tdongsi.github.io/java/blog/categories/java/atom.xml" rel="self"/>
  <link href="http://tdongsi.github.io/java/"/>
  <updated>2018-08-19T21:54:36-07:00</updated>
  <id>http://tdongsi.github.io/java/</id>
  <author>
    <name><![CDATA[Cuong Dong-Si]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Advanced Java Part 1]]></title>
    <link href="http://tdongsi.github.io/java/blog/2018/03/25/advanced-java-part-1/"/>
    <updated>2018-03-25T14:35:11-07:00</updated>
    <id>http://tdongsi.github.io/java/blog/2018/03/25/advanced-java-part-1</id>
    <content type="html"><![CDATA[<p>Based on Part 1: &ldquo;Interfaces, Inheritances, and Objects&rdquo; of <a href="https://www.safaribooksonline.com/library/view/advanced-java-development/9781491960400/video247566.html">SafariBooks&rsquo;s Advanced Java Development</a>
by Ken Kousen.</p>

<!--more-->


<h3>Default and static methods</h3>

<h4>Why static method in interface?</h4>

<p>Before Java 8, it is hard to add static methods that work on objects of the same type.
For example, <code>sort</code> method should work on all Collection objects.
However, we donâ€™t have that in Collection interface.
We end up working around by adding all static methods into Collections (plural) class.
That is how we end up with <code>Collections.sort()</code>.</p>

<p>After Java 8, the above problem is sorted out with static method in interfaces.
For example, Stream is an interface but it has utility methods such as &ldquo;Stream.of(a, b, c)&rdquo; which is static method.</p>

<h4>Default methods in interface</h4>

<p>What if default methods in two interfaces have the same name and a class implements both interfaces?
You have to override the method in the class to provide the specific implementation.
Otherwise, you will get the compilation error.
Note that, it is different from two abstract classes since it is usually required (before Java 8) for the class to provide concrete implementation for an interface method.
You can still refer to the default methods in the interfaces as follows:</p>

<pre><code class="java Default methods with same name in interfaces">public interface Company {
    default String getName() { return "defaults.Company"; }
}

public interface Contractor {
    String getFirst();
    String getLast();
    default String getName() { return String.format("%s %s", getFirst(), getLast()); }
}

public class CompanyContractor implements Company, Contractor {

    ...

    @Override
    public String getName() {
        return Contractor.super.getName() + " at " + Company.super.getName();
    }
}
</code></pre>

<h3>Exceptions</h3>

<p>The following exmample demonstrates how &ldquo;try-with-resources&rdquo; clauses can simplify codes that would be otherwise verbose before Java 7.
In this example, let&rsquo;s open a file and read it.
Although it uses Java 7&rsquo;s NIO classes, all exception-related tasks apply.</p>

<pre><code class="java ">    Path dir = Paths.get("src", "main", "java", "my", "learning", "advanced", "one");
    try {
        BufferedReader br = Files.newBufferedReader(dir.resolve("ExceptionDemo.java"));
        System.out.println(br.readLine());
    } catch (IOException e) {
        e.printStackTrace();
    }
</code></pre>

<p>The missing piece in the above code is that you need to properly close the file should any exception happens.
Now, the problem is that simply adding the following would not work since <code>br</code> is a local variable in <code>try</code> block.</p>

<pre><code class="java">finally {
    br.close();
}
</code></pre>

<p>In the end, you would end up with so much additional works just to make sure the file is closed should any exception happens, as shown in the following code.</p>

<ul>
<li>Declare a null <code>br</code> outside of try-catch block to make it visible in <code>finally</code> block.</li>
<li>Add <code>finally</code> block to close the file.</li>
<li>Additional null-check for <code>br</code> before closing the file.</li>
<li>Additional try-catch block for closing the file in <code>finally</code> block.</li>
</ul>


<pre><code class="java">    Path dir = Paths.get("src", "main", "java", "my", "learning", "advanced", "one");
    BufferedReader br = null;
    try {
        br = Files.newBufferedReader(dir.resolve("ExceptionDemo.java"));
        System.out.println(br.readLine());
    } catch (IOException e) {
        e.printStackTrace();
    } finally {
        if (br != null) {
            try {
                br.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
</code></pre>

<p>Such code is verbose and obfuscating the simple purpose of closing the file.
It is also distracting developers and reviewers from the main code of reading and processing the file.</p>

<p>With Java 7&rsquo;s &ldquo;try-with-resources&rdquo;, the above problem is effectively solved:</p>

<pre><code class="java">    Path dir = Paths.get("src", "main", "java", "my", "learning", "advanced", "one");
    try( BufferedReader br = Files.newBufferedReader(dir.resolve("ExceptionDemo.java")) ) {
        System.out.println(br.readLine());
    } catch (IOException e) {
        e.printStackTrace();
    }
</code></pre>

<p>We only need to move the BufferedReader instatiation into the <code>try()</code> statement.
No additional line is required at all.
The only requirement is that the BufferedReader class has to implement AutoCloseable interface, which it does.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java 9]]></title>
    <link href="http://tdongsi.github.io/java/blog/2017/12/06/java-9/"/>
    <updated>2017-12-06T12:11:16-08:00</updated>
    <id>http://tdongsi.github.io/java/blog/2017/12/06/java-9</id>
    <content type="html"><![CDATA[<p>JDK 9 was released in September and includes many changes to the Java platform.
The biggest is the Java Platform Module System (often referred to as Project Jigsaw).</p>

<!--more-->


<p>This new JPMS breaks up the existing rt.jar file into 97 modules (28 of them are SE) but also encapsulates internal APIs, such as sun.misc.Unsafe that have previously been available to developers.
This note summarizes some intersting points from a guest speaker about the new JDK 9 and other intersting changes in Java Community.</p>

<h3>JDK 9 Features</h3>

<p>Java Platform Module System</p>

<ul>
<li>Initially, leave everything on the classpath.</li>
<li>Anything on the classpath is in the unamed module

<ul>
<li>All packages are exported</li>
<li>The unamed module depends on all modules</li>
</ul>
</li>
<li>Migrate to modules as required</li>
</ul>


<p><code>--illegal-access</code> option is the Kill Switch to turn off encapsulation:</p>

<ul>
<li>permit: Warning for first use of an encapsulated API</li>
<li>warn: Warning for every use</li>
<li>debug: Warning and stack trace for every use</li>
<li>deny: No access.</li>
</ul>


<p><code>--add-exports</code> option allows direct access to encapsulated APIs.
<code>--add-opens</code> option allows reflective access to encapulated APIs.</p>

<p><code>jlink</code>: The Java Linker (JEP 282).
The implication of <code>jlink</code> is that the slogan &ldquo;Write once, run anywhere&rdquo; might not be true anymore.
<code>jlink</code> generated runtime may not include all Java SE modules.
It is still a conformant Java implementation.</p>

<p><a href="https://www.journaldev.com/13121/java-9-features-with-examples"><strong>REFERENCE</strong></a> with examples.</p>

<h3>Java Development Changes</h3>

<p>OpenJDK have a new release model: more agile, every six months.
Features are included when ready instead of targeted for specific release when started.</p>

<p>JDK Version Numbering: new scheme introduced (JEP 223).</p>

<ul>
<li>JDK MAJOR.MINOR.SECURITY</li>
<li>Semantic versioning</li>
</ul>


<p>However, there is a new scheme proposed in JEP 322: FEATURE.INTERIM.UPDATE.PATCH.</p>

<p>Availability of JDK updates: Oracle is switching to LTS model.</p>

<ul>
<li>JDK 8 is a LTS release.

<ul>
<li>It will have updates for more than 3 years.</li>
</ul>
</li>
<li>JDK 9 is a feature release.

<ul>
<li>Public updates are only available until next feature release.</li>
</ul>
</li>
</ul>


<h3>Deprecated features in JDK 9</h3>

<ul>
<li>Applets as a deployment mechanism</li>
<li>CMS garbage collector</li>
<li>Java policy tool, jconsole, Doclet API</li>
<li>No more 32-bit Oracle JDK binaries. No more ARM binaries.

<ul>
<li>Only Mac, Windows, Linux, SPARC supported. All 64-bit.</li>
</ul>
</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Date and Time in Java 7 vs Java 8]]></title>
    <link href="http://tdongsi.github.io/java/blog/2016/12/27/date-and-time-in-java-7-vs-java-8/"/>
    <updated>2016-12-27T18:50:15-08:00</updated>
    <id>http://tdongsi.github.io/java/blog/2016/12/27/date-and-time-in-java-7-vs-java-8</id>
    <content type="html"><![CDATA[<p>This post discuss how you handle date and time data in Java 8 and compare it with Java 7.</p>

<!--more-->


<h3>Date and Time in Java 8</h3>

<p><code>java.time</code> is the new package in Java 8 for handling date and time.
It is heavily based on <code>joda-time</code> package which is the de facto standard Java package for handling date &amp; time before Java 8.
This hopefully will put an end to the messy Date &amp; Time classes in <code>java.util</code> package.</p>

<pre><code class="java java.time demos">// Instant
Instant now = Instant.now();
System.out.printf("Instant.now(): %s%n", now);

// Duration
Instant then = now.plus(1, ChronoUnit.DAYS);
Duration elapsed = Duration.between(now, then);
System.out.printf("Duration: %s%n", elapsed);
System.out.printf("Duration in hours: %d hours %n", elapsed.toHours());

then = now.plus(1, ChronoUnit.DAYS)
    .plus(1, ChronoUnit.HALF_DAYS)
    .plus(1, ChronoUnit.HOURS)
    .plus(10, ChronoUnit.MINUTES)
    .plusSeconds(10);
System.out.printf("Then: %s %n", then);

// LocalDate
LocalDate localNow = LocalDate.now();
System.out.printf("LocalDate.now(): %s%n", localNow);

// Factory method
LocalDate firstDayOfSpring = LocalDate.of(2017, Month.MARCH, 20);
System.out.printf("First day of spring %s falls on %s%n", firstDayOfSpring, firstDayOfSpring.getDayOfWeek());

// Time zones
Set&lt;String&gt; allTimeZones = ZoneId.getAvailableZoneIds();
System.out.printf("Total number of time zones: %d%n", allTimeZones.size());
allTimeZones.stream().filter(name -&gt; name.contains("America")).forEach(System.out::println);

// ZonedDateTime
ZonedDateTime missing = ZonedDateTime.of(
    LocalDate.of(2016, Month.MARCH, 13),
    LocalTime.of(2, 30),
    ZoneId.of("America/New_York"));
System.out.println(missing);

// DateTimeFormatter
DateTimeFormatter formatter = DateTimeFormatter.ofLocalizedDateTime(FormatStyle.LONG)
    .withLocale(Locale.FRANCE);
System.out.println(formatter.format(missing));

// From Javadoc
LocalDate customerBirthday = firstDayOfSpring;
LocalDate today = LocalDate.now();
if (customerBirthday.equals(today)) {
LocalDate specialOfferExpiryDate = today.plusWeeks(2).with(TemporalAdjusters.next(DayOfWeek.FRIDAY));
// customer.sendBirthdaySpecialOffer(specialOfferExpiryDate);
}
</code></pre>

<h3>Compared with Java 7</h3>

<p>Handling date time data in Java 8 seems more elegant although not obvious.
As an example, the code for solving the same date time problem (<a href="https://projecteuler.net/problem=19">Project Euler number 19</a>) in Java 7 and 8 are shown below:</p>

<pre><code class="java Solving Project Euler 19 in Java 8">long count = 0;
for (int year = 1901; year &lt;= 2000; year++) {
    for (Month month: Month.values()) {
        LocalDate date = LocalDate.of(year, month, 1);
        if (date.getDayOfWeek() == DayOfWeek.SUNDAY) {
            count++;
        }
    }
}
</code></pre>

<pre><code class="java Solving Proiect Euler 19 in Java 7">int count = 0;
Calendar calendar = new GregorianCalendar();

// From year 1901 to 2000.
for ( int year=1901; year &lt;= 2000; year++ )
{
    // From month January to December
    for ( int month = 0; month &lt; 12; month++ )
    {
        // Set to the first day of the month
        calendar.set(year, month, 1);

        // If the date is Sunday
        if ( calendar.get(Calendar.DAY_OF_WEEK) == Calendar.SUNDAY )
        {
            count++;
        }
    }
}
</code></pre>

<p>As you can see, the code is pretty much similar although the Java 8 code seems more elegant IMO (no mutable object).
Although it is not obvious in the examples above, the Java 7 date and time can be awkward with some subtle pitfalls.
For example, the MONTH field of the Calendar class does not go from 1 to 12 like they do when we write dates otherwise.
Instead the months run from 0 to 11, where 0 is January and 11 is December, as seen in <code>calendar.set(year, month, 1)</code> above.
Further more, the day of week runs from 1 to 7 but Sunday, not Monday, is the first day of the week.
These can cause subtle bugs if you are not aware and apply precaution.</p>

<h3>Reference</h3>

<ul>
<li><a href="http://tutorials.jenkov.com/java-date-time/java-util-calendar.html">Java 7 examples</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java 8]]></title>
    <link href="http://tdongsi.github.io/java/blog/2016/12/17/java-8/"/>
    <updated>2016-12-17T22:37:46-08:00</updated>
    <id>http://tdongsi.github.io/java/blog/2016/12/17/java-8</id>
    <content type="html"><![CDATA[<p>This post discusses various new features in Java 8.
Java 8 is considered the latest Long-Term Support (LTS) release in new Java release schedule.</p>

<!--more-->


<h3>Lambdas</h3>

<pre><code class="java Different forms">final int MULTIPLIER = 2;
// "local variables referenced from a lambda expression/inner class must be final or effectively final"
int aMultiplier = 3;

// Simplest lambda form
Stream.of(3, 1, 4, 1, 5, 9)
        .forEach(n -&gt; System.out.println(n));

// Full lambda form
Stream.of(3, 1, 4, 1, 5, 9)
        .forEach((Integer n) -&gt; {
            System.out.println(n * MULTIPLIER);
        });

// Classic equivalent: anonymous inner class
Stream.of(3, 1, 4, 1, 5, 9)
        .forEach(new Consumer&lt;Integer&gt;() {
            @Override
            public void accept(Integer integer) {
                System.out.println("Second: " + integer * aMultiplier );
            }
        });
</code></pre>

<h3>Streams</h3>

<p>There are many ways to produce streams.</p>

<ul>
<li>Stream.of()</li>
<li>Stream.iterate()</li>
<li>Stream.generate()</li>
<li>Special methods in classes. E.g.:

<ul>
<li>Collections.stream()</li>
<li>Random.doubles()</li>
</ul>
</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Common Interview Questions]]></title>
    <link href="http://tdongsi.github.io/java/blog/2016/09/09/common-interview-questions/"/>
    <updated>2016-09-09T00:50:08-07:00</updated>
    <id>http://tdongsi.github.io/java/blog/2016/09/09/common-interview-questions</id>
    <content type="html"><![CDATA[<p>Common interview questions that are specific to Java language.</p>

<!--more-->


<h3>Trivia Questions</h3>

<p>The full list is <a href="http://javarevisited.blogspot.sg/2015/10/133-java-interview-questions-answers-from-last-5-years.html">here</a>.</p>

<ol>
<li>Why constructors dont return any value. What problem did Java face in returning a value from Constructors?

<ul>
<li>So the reason the constructor doesn&rsquo;t return a value is because it&rsquo;s not called directly by your code, it&rsquo;s called by the memory allocation and object initialization code in the runtime.
Its return value (if it actually has one when compiled down to machine code) is opaque to the user - therefore, you can&rsquo;t specify it.</li>
</ul>
</li>
<li>Difference between abstract class and interface?

<ul>
<li>The question is lame. However, it comes up so often that you have to get ready for it.
Failing to give the expected answer can make you fail in the phone screen.</li>
<li>Answer <a href="http://javarevisited.blogspot.com/2013/05/difference-between-abstract-class-vs-interface-java-when-prefer-over-design-oops.html">here</a>.</li>
</ul>
</li>
<li>What is string immutable? What is intern() method on String?</li>
<li>What is the difference between StringBuilder vs. StringBuffer? Vector and ArrayList?</li>
<li>Generics: is there any way to get the generic type in your program? (Answer: no due to type erasure)</li>
<li>Design pattern: what do you know? Which one do you use most? In what situation?</li>
<li>What is the <code>finalize()</code> method?

<ul>
<li>Finalizers are unpredictable, often dangerous, and generally unnecessary.
Only use it when you need a safety-net, a reminder to call explicit termination method OR you work with native methods and objects.</li>
</ul>
</li>
</ol>


<p>Java:</p>

<ul>
<li>Methods of Object class (relation between hashCode() and equals(), give a simple algorithm to do hashCode(), when to use finalize()). See chapter in Effective Java (see wiki)

<ul>
<li>equals() compare the hash code that is generated by hashCode(), usually different for different instances. If the two different objects, such as String, have equals() as true, the equals() function must be overridden.</li>
<li>Simple hashCode: use the time of creation.</li>
</ul>
</li>
<li>Collections framework (when to use Map, List, Set; implementations of those). See wiki</li>
<li>Some details about frequently used classes: String class (e.g., what intern() method does), StringBuilder vs. StringBuffer</li>
<li>Java I/O: using Scanner, printf, InputStream</li>
<li>Java generics: erasure, Java generics vs. C++ template</li>
<li>It&rsquo;s very impressive if you know about Java concurrency: e.g., what is volatile? when to use it? synchronize?</li>
</ul>


<p>20) From this book, which methods are invoked? Classes are extended as Dessert &lt;- Cake &lt;- ChocolateCake, and Dessert &lt;- Scone &lt;- ButteredScone.</p>

<pre><code class="java">// Overloaded method forms
void more( Dessert d, Scone s ) { }
void more( Cake c, Dessert d ) { }
void more( Chocolatecake cc, Scone s ) { }
void more( Dessert... desserts ) { }

// Method invocations
more( dessertRef, sconeRef ) { }
more( chocolateCakeRef, dessertRef ) { }
more( chocolateCakeRef, butteredSconeRef ) { }
more( cakeRef, sconeRef ) { }
more( sconeRef, cakeRef ) { }
</code></pre>

<h3>Singleton design pattern</h3>

<p>See <a href="http://tdongsi.github.io/SqlTests/blog/2011/01/21/classic-interview-questions/">here</a>.</p>
]]></content>
  </entry>
  
</feed>
